работа с файловыми системами реализована с помощью системных вызовов
с помощью специального механизма ОС обращается к ядру и просит выполнить что-то - это и есть системный вызов

сначала мы говорим ОС как мы будем работать с файлом - в режиме чтения, записи или еще как-нибудь
ОС сначала смотрит существует ли файл? есть ли на него у нас права? не директория ли? после присваивает этому файлу файловый дескриптер
в ядре ОС хранится таблица файловых дескриптеров 
ФД - просто номер записи в этой таблице
в самом начале атам хранятся числа 0, 1 и 2 - стандартные потоки ввода, вывода и ошибок. они создаются автоматически
каждый вызов getchar() и тд - на самом деле системный вызов
когда файл становится не нужен - происходит системный вызов close. это выглядит как обертка-функция над СВ, но на самом деле все сложнее
когда вызывается close, запись в таблице ФД удаляется 
СВ - довольно дорогая штука. поэтому вместо функций read и close используются различные обёртки над ними
существует переменная stdin - файл стандартного ввода

функция fopen, в отличие от функции open, возвращает не ФД, а указатель на структуру
FILE* f = fopen("file", "r");
"ни один человек в здравом уме не захочет смотреть поля структуры FILE"; но там точно содержиться ФД
все остальные функции как раз требуют указать f для работы
например, закрытие файла: fclose(f);

когда-то давно была разница между открытием бинарных файлов и текстовых - разница заключалась в переносах строки. сейчас это уже неактуально.
сегодня разницы нет, так как линукс - POSIX система (кто?)
режимы чтения:
b - binary (не нужен)
r - read 
w - write (файл при этом полностью обнуляется) 
a - append (write, но не обнуляет, а добавляет)

r+ - читать и записывать 
w+ - записывать и читать 
a+ - угадай что

есть СВ syscall: read, write; есть обёртки над ними: read(), write(); есть обёртки над ними: fread(), fwrite()

feof - проверка на ошибку
ferror - проверка на ошибку
fseek - передвинуться на определённое расстояние из определённого места
rewind - переместиться в начало файла


непосредственно про 6 курсач:
надо написать 2 программки 
1 - конвертирует данные из одного формата в другой, 2 - работает с ними
создаём текстовый файлик, разбитый на поля. 1 программа должна сделать из этого текстового файла бинарный

пример 1 проги:



habrapost.h:

typedef struct {
	int id;
	int rating;
	char name[256];
	char author[64];
} habrapost;

...

habrapost hp;

hp. ...

FILE *out = fopen("out.bin", "w");

fwrite(&hp, sizeof(habrapost), 1, out);

...

int main(int argc, char *argv[]){
		char *arg1 = argv[1];
}

// программе дают два аргумента: source и out. Например: ./a.out source.txt out.bin
Надо: проверить количество аргументов, открыть source на чтение и out на запись











































